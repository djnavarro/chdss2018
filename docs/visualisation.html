<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Danielle Navarro" />

<meta name="date" content="2018-12-11" />

<title></title>

<script src="site_libs/jquery/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap/shim/respond.min.js"></script>
<script src="site_libs/navigation/tabsets.js"></script>
<link href="site_libs/highlightjs/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs/highlight.js"></script>

<!-- ###### start inserted header ##### -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115940772-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-115940772-1');
</script>

<!-- add the twitter card and open graph tags -->
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@djnavarro">
<meta property="og:url" content="http://compcogscisydney.org/psyr/">
<meta property="og:title" content="R for Psychological Science">
<meta property="og:description" content="An introductory resource">
<meta property="og:image" content="http://compcogscisydney.org/psyr/img/splash_turtle.png">

<!-- ###### end inserted header ##### -->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="mystyle.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}

.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">CHDSS2018</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="program.html">program</a>
</li>
<li>
  <a href="venue.html">venue</a>
</li>
<li>
  <a href="participants.html">participants</a>
</li>
<li>
  <a href="resources.html">resources</a>
</li>
<li>
  <a href="coc.html">CoC</a>
</li>
<li>
  <a href="faq.html">FAQ</a>
</li>
<li>
  <a href="git.html">Git</a>
</li>
<li>
  <a href="projects.html">Projects</a>
</li>
<li>
  <a href="wrangling.html">Wrangling</a>
</li>
<li>
  <a href="visualisation.html">Visualisation</a>
</li>
<li>
  <a href="statistics.html">Statistics</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore"><div class="jumbotron">
<h1 class="title toc-ignore display-3">
Prettiness with ggplot2
</h1>
</div></h1>
<h4 class="author"><em>Danielle Navarro</em></h4>
<h4 class="date"><em>11 December 2018</em></h4>

</div>


<p>Visualising data is one of the most important tasks facing the data analyst. With that in mind, the structure of this chapter is as follows: I‚Äôll start out by giving you a very quick overview of how graphics work in R. I‚Äôll then discuss several different kinds of graph and how to draw them, as well as showing the basics of how to customise these plots. I‚Äôll then talk in more detail about R graphics, discussing some of those complicated and boring issues.</p>
<pre class="r"><code>library(here)
library(tidyverse)</code></pre>
<div id="r-graphics" class="section level2">
<h2>R graphics</h2>
<p>Reduced to its simplest form, you can think of R graphics like a painting. You start out with an empty canvas. Every time you use a graphics function, it paints some new things onto your canvas. Later you can paint more things over the top if you want, layering new information over the old. This way of thinking about plotting data is referred to as the <strong>painter‚Äôs model</strong> - the key thing to keep in mind is because the plot is constructed sequentially, the order in which you do things matters.</p>
<p>We can extend the painting metaphor a little. If you want to paint a picture, you need to paint it on something. In real life, you can paint on lots of different things. Painting onto canvas isn‚Äôt the same as painting onto paper, and neither is the same as painting on a wall. In R, the thing that you paint onto is called a <strong>graphics device</strong>. In RStudio, the default graphics device is <code>RStudioGD</code> and it corresponds to the ‚Äúplot‚Äù pane. If you were using the basic R program for Windows (i.e., <code>R.exe</code>) the default device is <code>windows</code>, on the Mac application (<code>R.app</code>) it‚Äôs called <code>quartz</code>, etc. However, from the computer‚Äôs perspective there‚Äôs nothing terribly special about drawing pictures on screen, and so R is quite happy to paint pictures directly into a file. R can paint several different types of image files: <code>jpeg</code>, <code>png</code>, <code>pdf</code>, <code>postscript</code>, <code>tiff</code> and <code>bmp</code> files are all available as graphics devices and you can write plots directly to those using those<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>Secondly, when you paint a picture you need to paint it with something. Maybe you want to do an oil painting, but maybe you want to use watercolour. And, generally speaking, you pretty much have to pick one or the other. The analog to this in R is a ‚Äúgraphics system‚Äù. A graphics system defines a collection of graphics commands about what to draw and where to draw it. Something that surprises most new R users is the discovery that R actually has several mutually incompatible graphics systems. The two of most interest to us are the <strong>base graphics</strong> system that comes with R and the <strong>ggplot2</strong> system<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> that forms part of <strong>tidyverse</strong>. There‚Äôs quite a difference of opinion among R users about the relative merits of these two systems. You can get started in base graphics really easily. To see just how easy it is, let‚Äôs load a new data set and try to draw a picture.</p>
<pre class="r"><code>frames &lt;- read_csv(here(&quot;analysis&quot;,&quot;data&quot;,&quot;frames_ex2.csv&quot;))
frames</code></pre>
<pre><code>## # A tibble: 4,725 x 8
##       id gender   age condition sample_size n_obs test_item response
##    &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
##  1     1 male      36 category  small           2         1        8
##  2     1 male      36 category  small           2         2        7
##  3     1 male      36 category  small           2         3        6
##  4     1 male      36 category  small           2         4        6
##  5     1 male      36 category  small           2         5        5
##  6     1 male      36 category  small           2         6        6
##  7     1 male      36 category  small           2         7        3
##  8     1 male      36 category  medium          6         1        9
##  9     1 male      36 category  medium          6         2        7
## 10     1 male      36 category  medium          6         3        5
## # ... with 4,715 more rows</code></pre>
<p>Using the tools from the last section, let‚Äôs also create a smaller summary data frame that contains one row per person:</p>
<pre class="r"><code>frames_small &lt;- frames %&gt;%
  group_by(id, gender, age, condition) %&gt;%
  summarise(response = mean(response))
frames_small</code></pre>
<pre><code>## # A tibble: 225 x 5
## # Groups:   id, gender, age [?]
##       id gender   age condition response
##    &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;
##  1     1 male      36 category      5.33
##  2     2 male      46 category      7.05
##  3     3 female    33 property      4.86
##  4     4 female    71 property      3.86
##  5     5 female    23 property      9   
##  6     6 female    31 category      7.90
##  7     7 male      23 property      3.76
##  8     8 female    31 property      4   
##  9     9 female    37 category      3.38
## 10    10 female    46 category      5.86
## # ... with 215 more rows</code></pre>
<p>Let‚Äôs see if we can understand what‚Äôs going on with this data set by drawing pictures, and also learn about R graphics in the process.</p>
</div>
<div id="histograms" class="section level2">
<h2>Histograms</h2>
<p>When analysing the data from this kind of experiment, one of the first things I check is that the <code>age</code> and <code>gender</code> variables are actually irrelevant. Honestly, I only bother to measure them at all because people seem to expect it in the literature but for the kind of questions I care about there‚Äôs never any effects of age or gender. Still, you have to check just to make sure nothing weird is goind on.</p>
<p>With that in mind, let‚Äôs give ourselves the task of drawing a histogram of the <code>age</code> variable in this data frame. We don‚Äôt need to make it pretty, we just want to plot the frequency distribution for the number of points scored by the home team. As I mentioned earlier, we could do this using base graphics or we could do it the tidyverse way. Let‚Äôs see how it plays out both ways.</p>
<p>The function to do this in base graphics is called <code>hist</code> and here it is:</p>
<pre class="r"><code>hist(frames_small$age)</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-3-1.png" width="672" /> It‚Äôs not exactly pretty ‚Äì though it‚Äôs way nicer than the default plots that I remember seeing when I was younger ‚Äì but it gets the job done.</p>
<p>Okay, how do I create a histogram the tidyverse way? Much like base graphics, <strong>ggplot2</strong> recognises that histograms are such a fundamentally useful thing that there exists a ‚Äúgeom‚Äù (a term I‚Äôll explain in a moment) for them, but there‚Äôs no way to draw a plot without going through a somewhat more convoluted process:</p>
<pre class="r"><code>frames_small %&gt;%
  ggplot(aes(x = age)) +
  geom_histogram()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-4-1.png" width="672" /> The output is prettier, admittedly, but our goal here wasn‚Äôt to be pretty. Our goal was to be simple. For this comparison, the tidyverse approach is not as straightforward as base graphics.</p>
<p>Where the tidyverse versions shines is when we want to do something a little bit more complicated. Suppose I wanted two histograms side by side, plotting the age distribution separately by <code>condition</code>. In base graphics, it‚Äôs a little cumbersome. What I have to do here is manually control the ‚Äúlayout‚Äù of the plot, dividing it into two separate panels and then drawing the histogram separately into each panel. That gives me code that looks like this:</p>
<pre class="r"><code>layout(matrix(1:2, 1, 2))
hist(frames_small$age[frames$condition == &quot;category&quot;])
hist(frames_small$age[frames$condition == &quot;property&quot;])</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>I need a lot more code as I did for the original version and I‚Äôve ended up with an ugly plot. Of course, base graphics absolutely does allow me to do a better job than this, but I hope you can see that it will take quite a bit of effort to turn this into something readable.</p>
<p>What about the <strong>ggplot2</strong> version? It turns out that it‚Äôs extremely easy. Splitting an existing plot into ‚Äúfacets‚Äù is a basic operation within <strong>ggplot2</strong> so all I need to do is add one line of code that specifies which variable to use to make the facets! The result is actually kind of nice:</p>
<pre class="r"><code>frames_small %&gt;%
  ggplot(aes(x = age)) +
  geom_histogram() +
  facet_wrap(~condition)</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>For me at least, this is the big advantage to the <strong>ggplot2</strong> approach. There‚Äôs a certain amount of effort required to construct the basic plot, but once that is done, you can modify or manipulate that plot in an extremely flexible fashion with very little effort indeed. What I‚Äôve found in practice is that the low-effort to making changes makes me much more willing to ‚Äúplay around‚Äù with different ways of visualising the data. So, while I‚Äôll admit that there are some situations where I resort to using base graphics (mostly when I have a very unconventional graph to draw), I tend to find the tidyverse approach works better in the majority of cases.</p>
<p>As far as what the data visualisation is telling us: the distribution of ages was mostly in the 20-40 age range with a modest positive skew. That‚Äôs pretty typical of these studies. More importantly, it‚Äôs pretty clear from inspection that there‚Äôs not much of a difference in the age distribition across conditions, which is what I‚Äôd hope to see given that people were assigned randomly.</p>
</div>
<div id="scatter-plot" class="section level2">
<h2>Scatter plot</h2>
<p>The second kind of plot I‚Äôll talk about is a scatter plot, in which each observation is drawn as a point, and the graph shows the values on one variable against the values on another. It‚Äôs such a simply plot that I‚Äôll use it as a mechanism to illustrate the key ideas in <strong>ggplot2</strong>.</p>
<p>Lets build our plot piece by piece. The data we want to use here come from <code>frames_small</code>, so the first thing we‚Äôll do is pipe this data set to the <code>ggplot()</code> function and see what it produces:</p>
<pre class="r"><code>frames_small %&gt;% 
  ggplot()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-7-1.png" width="384" /></p>
<p>In retrospect that‚Äôs unsurprising. Although we‚Äôve passed the data to <code>ggplot()</code>, we haven‚Äôt told R what it ought to <em>do</em> with these data, so the output is simply a blank canvas! To make some progress, the next step is to specify a <code>mapping</code> for the plot that will tell R something about what roles the different variables play. In <strong>ggplot2</strong> these mappings are described as a set of ‚Äú<em>aesthetics</em>‚Äù, defined using the <code>aes()</code> function. There are many different aesthetics that can be used, but for a scatter plot the only things we really <em>need</em> to specify as aesthetics are the variable on the <code>x</code> axis and the variable on the <code>y</code> axis. So if we wanted to plot <code>y = response</code> against <code>x = age</code>, this is the mapping we would need:</p>
<pre class="r"><code>frames_small %&gt;% 
  ggplot(mapping = aes(x = age, y = response))</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-8-1.png" width="384" /></p>
<p>Hm. That‚Äôs clearly some progress. The canvas now has the axis labels and gridlines reflecting the fact that R now knows which variables we‚Äôre hoping to ploy. However, we still don‚Äôt have any data, because we haven‚Äôt told R what it should <em>do</em> to render the data. This is the role played by <em>geoms</em>, which specify different ways in which data can be displayed. Since we‚Äôre trying to draw a scatter plot, I‚Äôm going to use the simplest possible <em>geom</em> function, namely <code>geom_point()</code>. All it does is draw a dot for each data point:</p>
<pre class="r"><code>frames_small %&gt;% 
  ggplot(mapping = aes(x = age, y = response)) +
  geom_point()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>Now we have our scatter plot! From visual inspection there doesn‚Äôt seem to be any strong relationship between the <code>age</code> of a participant and the <code>response</code> they give. Again, that‚Äôs not surprising, but useful to check.</p>
<p>It‚Äôs worth highlighting the different roles played by aesthetics and geoms. For instance, I could have expanded the list of aesthetics to include <code>colour = condition</code>, which would indicate that the colour of each dot should indicated which condition the participant in question was assigned to:</p>
<pre class="r"><code>frames_small %&gt;% 
  ggplot(mapping = aes(x = age, y = response, colour = condition)) +
  geom_point()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-10-1.png" width="480" /></p>
<p>However, I can also add new geoms that will draw new layers to the plot. For example, <code>geom_rug</code> adds a visual representation of the marginal distribution of the data on both axes, like this:</p>
<pre class="r"><code>frames_small %&gt;% 
  ggplot(mapping = aes(x = age, y = response, colour = condition)) +
  geom_point() + 
  geom_rug()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-11-1.png" width="480" /></p>
<p>Notice the style here. A pretty typical way to build a visualisation is to construct it in layers, <em>adding</em> new geoms, aesthetics and other plot customisations as you go. So you‚Äôll often end up with code structured like this:<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<pre><code>DATA %&gt;%
  ggplot(aes( LIST_OF_AESTHETICS )) +
  A_GEOM +
  ANOTHER_GEOM +
  ETC</code></pre>
<p>In any case, looking at these scatter plots there‚Äôs nothing that immediately suggests and differential patterns of responding as a function of age but there is a hint that responses are lower in the property sampling condition (blue) than in the category sampling condition (red).</p>
</div>
<div id="bar-graphs" class="section level2">
<h2>Bar graphs</h2>
<p>The humble bar graph is a staple in the scientific literature, and can be rendered by <strong>ggplot2</strong> with the assistance of the <code>geom_bar()</code> function. Suppose I want to check that the gender distribution for this study was relatively even across conditions.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> To do that, I‚Äôll set up my mapping with <code>gender</code> on the x-axis (using <code>ggplot</code> to initialise the plot and <code>aes</code> to specify the aesthetics), create separate panels for each <code>condition</code> (using <code>facet_wrap</code> which I‚Äôll explain in more detail below), and then use <code>geom_bar()</code> to draw the plot:</p>
<pre class="r"><code>frames_small %&gt;%
  ggplot(aes(x = gender)) +  # set up the mapping
  facet_wrap(~condition) +   # split it into plots
  geom_bar()                 # add the bars!</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>As one would expect for random assignment there‚Äôs a little unevenness but not very much. That looks totally fine to me, and at this point I‚Äôve convinced myself that the <code>age</code> and <code>gender</code> variables really don‚Äôt matter very much, so I can start digging into the details about how the manipulated variables of theoretical interest (<code>sample_size</code>, <code>condition</code> and <code>test_loc</code>) relate to the inductive generalisation <code>response</code> judgment that people make‚Ä¶</p>
</div>
<div id="box-plots" class="section level2">
<h2>Box plots</h2>
<p>Another classic data visualisation used in psychology is the box plot (due to John Tukey), which presents a schematic representation of the distribution of responses. Box plots can be drawn in many different forms, but the most conventional version the median value (50th percentile) as a thick horizontal line, contained within a box that spans the range from 25th percentile to the 75th percentile. Above and below the box are the ‚Äúwhiskers‚Äù which extend to cover the full range of the data (after excluding outliers). Outliers are plotted as individual dots. Note that in this context an outlier is conventionally defined as a point that lies more than 1.5 times the interquartile range from the median: this is often a convenient heuristic to use but it‚Äôs not magical. Don‚Äôt read too much into the fact that a data set includes outliers!</p>
<p>To construct a boxplot using <strong>ggplot2</strong> all we need to do is add a <code>geom_boxplot()</code> to the graph. So if I want to plot the distribution of <code>response</code> values across participants (averaged across test items) separately for each <code>condition</code>, I could do this:</p>
<pre class="r"><code>frames_small %&gt;%
  ggplot(aes(x = condition, y = response)) + 
  geom_boxplot()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>This plot is easy to interpret and provides our first hint that there is in fact something of interest going on in these data. On a first pass, it rather looks like people are less willing to make inductive generalisations (i.e., give lower scores) in the property sampling condition than in the category sampling condition!</p>
</div>
<div id="violin-plots" class="section level2">
<h2>Violin plots</h2>
<p>Although the box plot is an old method for visualising the key characteristics of distribution it‚Äôs a very good one. It‚Äôs visually simple, meaning that you can put a lot of box plots in a single graph without causing too much clutter, yet it still conveys a lot of information about the distribution. So there are many situations in which they are worth including (we‚Äôll see a good example in a moment)</p>
<p>On the other hand, for the specific situation here where there are only two disributions to be displayed, it does seem like we could do better. With the state of computing having advanced quite dramatically over recent decades, it is extremely easy to construct more complicated <em>kernel density estimates</em> of the shape of the population from which the sample is drawn. The <em>violin plot</em> provides a method for visually displaying a kernel density estimate. If we switch from <code>geom_boxplot()</code> to <code>geom_violin()</code> the resulting plot looks like this:</p>
<pre class="r"><code>frames_small %&gt;%
  ggplot(aes(x = condition, y = response)) + 
  geom_violin()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>It‚Äôs intuitively obvious what this plot is doing: the ‚Äúwidth‚Äù of the violin<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> at each point shows the estimated ‚Äúdensity‚Äù of the population distribution at that point. To make it a little clearer what this is showing, let‚Äôs overlay the raw data on the plot, using the <code>geom_jitter()</code> method to make it a little easier to see:</p>
<pre class="r"><code>frames_small %&gt;%
  ggplot(aes(x = condition, y = response)) + 
  geom_violin() +
  geom_jitter()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>As you can see, in the property sampling condition the data are concentrated pretty tightly around 4.5, whereas in the category sampling condition the data are shifted upwards and spread out. That‚Äôs what produces the different shapes in the violin plots.</p>
</div>
<div id="facetted-plots" class="section level2">
<h2>Facetted plots</h2>
<p>The big problem I have with the data visualisations we‚Äôve drawn so far is that we‚Äôre really not getting a very fine grained story. When we constructed the <code>response</code> variable for the <code>frames_small</code> data frame we averaged over all three values of <code>sample_size</code> and across all seven values of <code>test_loc</code>. That‚Äôs fine as a first pass if we want to take a quick look at the difference across <code>condition</code>, but in real world data analysis we need to hold ourselves to higher standards! So lets go back to the raw <code>frames</code> data, and see if we can find a better visualisation. This brings us naturally to the topic of <em>faceting</em> a plot‚Ä¶</p>
<p>A common task in data visualisation is to construct facet plots that display an existing plot separately for each group. We‚Äôve seen this twice already, once in the histogram at the start of this section and previously in the <a href="./prelude-to-data.html">prelude</a>. In both cases I used <code>facet_wrap()</code> to do the work, using the <code>~</code> operator to specify a one-sided formula (e.g., <code>~condition</code>). This function splits the plot by the levels of a factor, and then ‚Äúwraps‚Äù them around to keep the plot tidy. For example, if there were 16 levels of the <code>condition</code> variable then <code>facet_wrap()</code> would probably give us a 4x4 grid.</p>
<p>If you want more precise control over the faceting, an alternative approach is to use <code>facet_grid()</code>. For instance, let‚Äôs suppose I want to draw separate boxplots for the <code>response</code> variable for every possible <code>test_item</code>, broken down by <code>condition</code> and <code>sample_size</code>. That‚Äôs going to give us 42 boxplots, so some degree of care is required here! Here‚Äôs my first attempt:</p>
<pre class="r"><code>frames %&gt;%                               # start with the full data set!
  ggplot(aes(
    x = factor(test_item),               # treat &quot;test_item&quot; as categorical
    y = response)) +                     # y variable is &quot;response&quot;
  facet_grid(sample_size ~ condition) +  # add faceting
  geom_boxplot()                         # oh, right... add the boxplots :-)</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>That‚Äôs not bad as a first pass. There‚Äôs a few things I‚Äôd like to do to tidy it though:</p>
<ul>
<li>Flip the grid by changing the formula to <code>condition ~ sample_size</code></li>
<li>Reorder the sample size facets by changing <code>sample_size</code> to a factor</li>
<li>Adding nicer axis labels using <code>xlab()</code> and <code>ylab()</code></li>
<li>Make the ‚Äúoutliers‚Äù less obtrusive using transparency</li>
</ul>
<p>To do this, the first thing I‚Äôm going to do is use <code>dplyr::mutate</code> ‚Äì discussed in the previous section ‚Äì to convert the <code>sample_size</code> variable to a factor, and make sure the levels are specified in the order I want them to appear in the plot:</p>
<pre class="r"><code>frames &lt;- frames %&gt;%
  mutate(sample_size = factor(sample_size, levels = c(&quot;small&quot;,&quot;medium&quot;,&quot;large&quot;)))</code></pre>
<p>Now my command to draw the plot looks like this:</p>
<pre class="r"><code>frames %&gt;%                               
  ggplot(aes(
    x = factor(test_item),               
    y = response)) +                     
  facet_grid(condition ~ sample_size) +  # reversed faceting
  geom_boxplot(outlier.alpha = 0.1) +    # alpha sets the transparency
  xlab(&quot;Location of Test Stimulus&quot;) +    # add x-label
  ylab(&quot;Response&quot;)                       # add y-label</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-18-1.png" width="576" /></p>
<p>It‚Äôs essentially the same as before, but we‚Äôve switched the ordering of variables in <code>facet_grid()</code>, added the <code>outlier.alpha = 0.1</code> argument to <code>geom_boxplot()</code> to make the outliers fade into the background, and then specified some nicer axis titles. The resulting plot is a fair bit more readable.</p>
<p>As for what we‚Äôre seeing in the data, there are a few different things to notice:</p>
<ul>
<li>Within every facet the responses tend to shift <em>downwards</em> from left to right: as the test item becomes less similar to the training items, people are less willing to make generalisations. This pattern of similarity-based generalisation is unsurprising and it‚Äôs a finding that has been replicated many, many times in the literature.</li>
<li>The effect of sample size is inhomogeneous. For stimuli that are very similar to the training items (test locations 1 and 2), increasing the sample size pushes the generalisation <em>upwards</em>, regardless of whether category sampling or property sampling is applied</li>
<li>For stimuli that are very dissimilar (especially test items 6 and 7), the effect of sample size depends on the sampling method. For category sampling, basically <em>nothing happens</em>: the box plots for large sample sizes aren‚Äôt any different to those for small sample sizes. Yet for property sampling, there‚Äôs a systematic tendency for these to shift <em>downwards</em></li>
</ul>
<p>Assuming that these findings replicate<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> it looks like we have a three-way interaction of some kind!</p>
<p>To be honest though, I‚Äôm still not pleased with this graph. I think we can do better.</p>
</div>
<div id="bubble-plots" class="section level2">
<h2>Bubble plots</h2>
<p>One difficulty with box plots is that they only work as distributional summaries when the data are unimodal. If most people respond with extreme values, the box plot ends up being a little misleading. Violin plots are often better at capturing multimodality, but they‚Äôre designed to work for continuous variables and often behave poorly when applied to data that fall in a small number of ordered categories. Psychological data from questionnaires or ‚Äì as in the <code>frames</code> data set - other ordinal response methods often have exactly this characteristic. Neither box plots nor violin plots are ideally suited to this situation.</p>
<p>Fortunately a bubble plot can help out here. This takes the form of a scatter plot, but instead of plotting every data point as a unique dot, we plot dots at every location whose size (area) is proportional to the number of cases at that location.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> To do this with <strong>ggplot2</strong> all we need to do is use the <code>geom_count()</code> function. When applied to the <code>frames</code> data, we get this:</p>
<pre class="r"><code>frames %&gt;%
  ggplot(aes(x = test_item, y = response)) + 
  facet_grid(condition ~ sample_size) +
  geom_count()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-19-1.png" width="576" /></p>
<p>This version of the plot highlights a failure of the box plot version. Compare the distribution of responses to test item 7 in the category sampling condition (top row). In the <code>small</code> sample size, the modal response is 4, with most people using the middle category, whereas for the <code>large</code> sample size most people are using the extremes, responding with either 0 or 9. However, both cases have the same median and very similar inter-quartile ranges, so the box plots look almost the same!</p>
<p>On the other hand, this plot is a little hard to read. We‚Äôve added a lot of new detail about the low frequency responses and in doing so learned more about the overall distribution of responding, but that‚Äôs come at the cost of making it harder to see what the most typical responses are! A compromise that I am often fond of is using shading to slightly de-emphasize the low frequency cases. Larger bubbles should stand out (dark colour), but low frequency responses should fade into the light grey background. It‚Äôs actually pretty easy to do that: <code>geom_count()</code> keeps track of the number of observations in each cell, and so we can add a new aesthetic to the <code>geom_count()</code> layer, simply by specifying <code>colour = ..n..</code>:</p>
<pre class="r"><code>frames %&gt;%
  ggplot(aes(x = test_item, y = response)) + 
  facet_grid(condition ~ sample_size) +
  geom_count(aes(colour = ..n..))</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-20-1.png" width="576" /></p>
<p>That‚Äôs a little nicer, but in this case I don‚Äôt want or need the pretty blue colouring. What I want to do is specify my own grey scale, where larger dots are coloured closer to black (e.g., upper bound is <code>&quot;grey20&quot;</code>) and the smaller dots are coloured in a light grey (e.g., lower bound is <code>&quot;grey80&quot;</code>).<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> Then all I have to do is this:</p>
<pre class="r"><code>frames %&gt;%
  ggplot(aes(x = test_item, y = response)) + 
  facet_grid(condition ~ sample_size) +
  geom_count(aes(colour = ..n..)) + 
  scale_colour_gradient(low = &quot;grey80&quot;, high = &quot;grey20&quot;)</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-21-1.png" width="576" /></p>
<p>To my mind that‚Äôs much more readable! It captures the multimodality of the responding without overwhelming the viewer with too much detail. There are still some issues that you might want to care about in real life ‚Äì the figure is a little too low contrast for people with less than perfect vision, for instance. But it comes a lot closer to what we need.</p>
</div>
<div id="error-bars" class="section level2">
<h2>Error bars</h2>
<p>As much as I love the bubble plot above, academic journals often expect a more compressed representation of the data, especially when the manuscript you‚Äôre submitting involves a large number of experiments. It‚Äôs often the case that we want to summarise the data from a single condition using a ‚Äúmean plus error bar‚Äù style plot. A common format is to plot the mean for every experimental condition and have error bars plotting the 95% confidence interval for the mean. To do that for the <code>frames</code> data, let‚Äôs begin by constructing a summary data set</p>
<pre class="r"><code>frames_mean &lt;- frames %&gt;%
  group_by(condition,sample_size,test_item) %&gt;%
  summarise(
    mean_response = mean(response),
    lower = lsr::ciMean(response)[1],
    upper = lsr::ciMean(response)[2]
  )
frames_mean</code></pre>
<pre><code>## # A tibble: 42 x 6
## # Groups:   condition, sample_size [?]
##    condition sample_size test_item mean_response lower upper
##    &lt;chr&gt;     &lt;fct&gt;           &lt;int&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 category  small               1          6.07  5.55  6.59
##  2 category  small               2          6.26  5.84  6.69
##  3 category  small               3          5.87  5.50  6.24
##  4 category  small               4          5.11  4.74  5.49
##  5 category  small               5          4.55  4.12  4.99
##  6 category  small               6          4.16  3.69  4.63
##  7 category  small               7          3.98  3.44  4.52
##  8 category  medium              1          7.32  6.85  7.78
##  9 category  medium              2          7.17  6.80  7.54
## 10 category  medium              3          5.98  5.54  6.42
## # ... with 32 more rows</code></pre>
<p>In this case I‚Äôm using the <code>ciMean()</code> function from the <strong>lsr</strong> package to compute the 95% confidence intervals. Just so that you can see how this function works ‚Äì without all the additional complications from calling it within the <code>summarise()</code> operation ‚Äì here‚Äôs a simple example. I‚Äôll generate 20 numbers from a normal distribution with true mean 100 and true standard deviation 15 (following the convention used for IQ scores), and then use the <code>ciMean()</code> function to calculate a 95% confidence interval:</p>
<pre class="r"><code>fake_iq &lt;- rnorm(n = 20, mean = 100, sd = 15)  # normally distributed data
lsr::ciMean(fake_iq)                           # 95% confidence interval </code></pre>
<pre><code>##             2.5%  97.5%
## fake_iq 95.07818 106.79</code></pre>
<p>So the <code>lower</code> variable in <code>frames_mean</code> is the lower bound on the 95% confidence interval, and <code>upper</code> is the upper bound. In any case, now that we have data in an appropriate format we can create the plot.</p>
<p>To add error bars is no more difficult than anything else in <strong>ggplot2</strong>. There is a geom called <code>geom_errorbar()</code> that will draw those for us. However, it does need some new information. In our previous graphs we‚Äôve specifed three aesthetics at the beginning of our graphing exercise, namely <code>x = test_item</code>, <code>y = mean_response</code> and <code>colour = condition</code>. That works fine for <code>geom_point()</code> because doesn‚Äôt need anything else, but <code>geom_errorbar()</code> also needs to know which variables specify the <code>ymin</code> and <code>ymax</code> values that will be displayed in the error bars. If I wanted to, I could could include these aesthetics within the original call to <code>ggplot()</code> but I‚Äôll do something a little different this time. Individual geoms can have their own unique aesthetics, so I can insert a new call to <code>aes()</code> within the <code>geom_errorbar()</code> call. Conceptually I find this neater, because it makes clear that <code>ymin</code> and <code>ymax</code> are aesthetics that apply to the error bars, but not to other geoms in the plot. Anyway here‚Äôs the command:</p>
<pre class="r"><code>my_pic &lt;- frames_mean %&gt;%
  ggplot(aes(x = test_item, y = mean_response, colour = condition)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower, ymax = upper)) +  # add the error bars!
  facet_wrap(~sample_size)</code></pre>
<p>Hey, where‚Äôs my plot? Oh right‚Ä¶ notice that I assigned the result to a variable called <code>my_pic</code>. Under the hood, <code>my_pic</code> is essentially a big list of information that specifies everything R needs to know to draw the plot. So if we want to <em>see</em> the plot, all we need to do is call <code>print(my_pic)</code> or <code>plot(my_pic)</code>, or even more simply I can do this:</p>
<pre class="r"><code>my_pic</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-25-1.png" width="576" /></p>
<p>Clearly, when compared to the bubble plot we are losing a lot of information ‚Äì all we have left is information about the distributional mean ‚Äì but it‚Äôs still fairly informative about what is going on across the diferent conditions.</p>
<p>Another thing worth noting. Because the test items vary along a continuous scale, it‚Äôs appropriate to connect the points with lines. I can do this in a straightforward way simply by adding <code>geom_line()</code> to the plot:</p>
<pre class="r"><code>my_pic + geom_line()</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-26-1.png" width="576" /></p>
<p>Notice that I can add <code>geom_line()</code> directly to <code>my_pic</code>. That can be extremely handy if you‚Äôve worked out what the core features of your plot will be and want to play around with a few possible additions to the plot.</p>
</div>
<div id="other-possibilities" class="section level2">
<h2>Other possibilities</h2>
<p>As you can see, there are quite a few things you can do with this package. However, the <strong>ggplot2</strong> package provides many more plotting tools than I‚Äôve described so far, and it was designed to be extensible so there are many other packages that extend it in interesting ways. Even without looking at other packages, there are various neat possibilities. Just to give you a bit of a sense of this, here are a few more! If I want to add contouring to a scatter plot, I can do this using the <code>geom_density_2d()</code> function:</p>
<pre class="r"><code>frames_small %&gt;% 
  ggplot(mapping = aes(x = age, y = response, colour = condition)) +
  geom_point() + 
  theme_bw() +
  geom_density_2d() +
  facet_wrap(~condition) +
  ylim(0,9)</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-27-1.png" width="576" /></p>
<p>Alternatively, if I want to add regression lines to this plot I can use <code>geom_smooth()</code>. By default the <code>geom_smooth()</code> function applies a non-linear method (loess regression), which we saw previously in the <a href="./prelude-to-data.html">prelude</a>. This is also customisable. If I want to use a simpler linear model to provide my regression line, all I need to do is specify <code>method = &quot;lm&quot;</code> and I get a plot like this:</p>
<pre class="r"><code>frames_small %&gt;% 
  ggplot(mapping = aes(x = age, y = response, colour = condition)) +
  geom_point() + 
  geom_smooth(method = &quot;lm&quot;) +
  facet_wrap(~condition) +
  ylim(0,9)</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<p>Similarly, plots are customisable in other ways. We can use <code>theme_dark()</code> to switch to a dark theme or <code>theme_bw()</code> to switch to a black and white scheme. We can add horizontal lines to plots with <code>geom_hline()</code>, vertical lines with <code>geom_vline()</code> and diagonal lines with <code>geom_abline()</code>. The colour palette can be adapted in arbitrary ways (e.g.¬†with <code>scale_color_brewer</code>). We can control the axis scales with <code>xlim()</code> and <code>ylim()</code>. We can add text to a plot with <code>geom_text()</code>. Here‚Äôs an example showing some of those customisation:</p>
<pre class="r"><code>my_new_pic &lt;- my_pic + 
  theme_dark() +
  scale_color_brewer(palette = &quot;Pastel2&quot;) +
  ylim(0, 9) + 
  geom_vline(xintercept = 2.5, colour = &quot;white&quot;, lty = &quot;dotted&quot;) +
  xlab(&quot;Location of Test Stimulus&quot;) +
  ylab(&quot;Mean Response&quot;)

my_new_pic</code></pre>
<p><img src="visualisation_files/figure-html/unnamed-chunk-29-1.png" width="576" /></p>
<p>The possibilities are limited mostly by your imagination, and by common sense. The <strong>ggplot2</strong> system is so rich and flexible that it‚Äôs easy to go overboard with creating pretty pictures. Always remember that there‚Äôs a human reader at the other end of your picture, and they‚Äôre more interested in what your data visualisation can tell them about <em>the data</em>, not what it says about your R skills! üòÄ</p>
</div>
<div id="saving-images" class="section level2">
<h2>Saving images</h2>
<p>The last topic I want to cover here is how to save your plot to an image file. Suppose I want to take <code>my_new_plot</code> and save it to a PNG file that is 16cm wide and 8cm high. The <code>ggsave()</code> function allows me to do that, and the command is pretty intuitive:</p>
<pre class="r"><code>ggsave(
  filename = &quot;./output/frame_pic.png&quot;,
  plot = my_new_pic,
  width = 16,
  height = 8,
  units = &quot;cm&quot;
)</code></pre>
<p>The function is smart enough to guess from the <code>filename</code> argument what kind of image file to create (e.g., PNG, JPG, etc), and so as long as the filename specifies a file extension that <code>ggsave()</code> can handle it will automatically create the right kind of image.</p>
</div>
<div id="more-resources" class="section level2">
<h2>More resources</h2>
<ul>
<li><a href="https://www.r-graph-gallery.com/" class="uri">https://www.r-graph-gallery.com/</a></li>
</ul>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you are interested, take a look at the various <code>dev</code> functions for working with graphics devces, such as <code>dev.new</code>, <code>dev.print</code>, <code>dev.off</code> etc. I won‚Äôt talk about those here because I‚Äôm focusing on <strong>tidyverse</strong> but they‚Äôre handy in other situations<a href="#fnref1">‚Ü©</a></p></li>
<li id="fn2"><p>It‚Äôs worth acknowledging that <strong>ggplot2</strong> and builds off the <strong>grid</strong> graphics system that we very briefly encountered when using <strong>TurtleGraphics</strong><a href="#fnref2">‚Ü©</a></p></li>
<li id="fn3"><p>There is a little bit of weirdness to this. Once you‚Äôve gotten accustomed to using the pipe operator <code>%&gt;%</code> it starts to feel like we should be writing code like <code>data %&gt;% ggplot() %&gt;% geom() %&gt;% etc</code> rather than <code>data %&gt;% (ggplot() + geom() + etc)</code>. This is purely for historical reasons: <strong>ggplot2</strong> predates the pipe operator and so unlike everything else in <strong>tidyverse</strong> it‚Äôs not very compatible with <code>%&gt;%</code>.<a href="#fnref3">‚Ü©</a></p></li>
<li id="fn4"><p>In this study I asked people to respond with a three value questionnaire, with options for ‚Äúmale‚Äù, ‚Äúfemale‚Äù and ‚Äúother‚Äù as possible gender identities. I‚Äôm not entirely satisfied with this as a measurement method though, and the question wasn‚Äôt compulsory to answer.<a href="#fnref4">‚Ü©</a></p></li>
<li id="fn5"><p>Yeah, they never actually look like violins. We should just give up and call them blob plots<a href="#fnref5">‚Ü©</a></p></li>
<li id="fn6"><p>They appear to ‚Äì we ran 9 experiments in total and while some effects are a little fragile and I wouldn‚Äôt put too much faith in their ability to replicate, the core effect in which there are systematic differences in how statistical information (e.g., sample size, base rate, auxiliary data) interacts with the sampling mechanism replicated every time; oh and if you go read the paper the model predictions correlate with human data very highly, always produce the same qualitative patterns regardless of parametre values‚Ä¶ etc, etc. This isn‚Äôt a cognitive science paper so I won‚Äôt bore you with details, but the reason this works as cleanly as it does is that we didn‚Äôt choose these manipulations arbitrarily. We had a proper theory to guide us!<a href="#fnref6">‚Ü©</a></p></li>
<li id="fn7"><p>There are drawbacks to bubble plots. The psychophysical function for area isn‚Äôt linear, so subjective area doesn‚Äôt scale perfectly with actual area. If you need people to be able to make fine-grained comparisons between quantities don‚Äôt use bubble plots. However, my goal here is different - I don‚Äôt mind if we can‚Äôt quite see the ‚Äúperfect‚Äù relationship, I just want the ‚Äúgist‚Äù to come through properly.<a href="#fnref7">‚Ü©</a></p></li>
<li id="fn8"><p>R is quite flexible in how it handles colours. For most purposes you can use an English colour word and R will have a rough idea what you mean. Type <code>colours()</code> at the console to see a list of the colour names it knows: there are a lot! Alternatively you can specify a hexadecimal string like <code>#88398A</code>, or use a function like <code>rgb()</code> or <code>hsv()</code> to construct the colour you want.<a href="#fnref8">‚Ü©</a></p></li>
</ol>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
